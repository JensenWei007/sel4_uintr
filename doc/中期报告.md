# 中期报告-2112495魏靖轩

## 选题描述

选题是面向rel4操作系统的用户态中断机制研究。

选题主要面向的其实是两个研究点-微内核和用户态中断，其中微内核在最近几年越来越火热，影响力越来越大，其不同于宏内核的内核架构设计带来了很多不同于Linux等传统宏内核的特性，但是也相应的在这种架构下带来了宏内核所没有的瓶颈。于微内核而言，他的系统服务不是通过传统的系统调用完成，微内核所支持的系统调用只有IPC机制，用户程序所需要的服务都是通过IPC+函数调用的方式完成，因此IPC是微内核中最重要、也是最热点的路径，该路径的性能将会最大程度上影响微内核的性能。

用户态中断是一种新的硬件特性, 使得用户态的程序能够接受到中断, 并进入指定的中断处理函数中, 中断过程由硬件发送, 无需经过内核。本项目探索运用新一代 Intel 硬件特性用户态中断，搭建运行环境, 进行IPC的性能测试并与传统IPC方式进行比较。因其不需要进过内核, 从而性能相比传统IPC节省掉了trap等的开销，性能会优于现有的IPC路径。此外由于用户态中断不同于以往的通知机制的特性，他可以借助中断的特点实时打断目标进程，因此对于用户态程序而言，可以实现异步IO下双向的异步调用过程, 在保证异步基本的特性的情况下获取了更低的io延迟。

## 国内外研究进展综述

### 微内核：

Microkernel Goes General: Performance and Compatibility in the HongMeng Production Microkernel

这篇文章是标志微内核正式走向消费者端的商用开端，随着华为 HarmonyOS Next 的上市，全世界第一个商用微内核进入了消费者端。这篇文章详细介绍了华为的鸿蒙内核的微内核架构。

于Linux而言，其通用性并没有做的十分完美，且设备驱动都在内核中导致其安全问题频发，同时其定制化成本非常高。相比之下，微内核其他功能都放在用户空间，安全性和拓展性更好。但这并不是免费的午餐，代价是性能往往会有很大的挑战。

但在鸿蒙（HM）所关注的新兴场景，比如智能手机、智能汽车等，情况截然不同，应用程序种类繁多且动态变化，资源竞争激烈，内核需要提供复杂的、动态的资源管理功能，以有效协调和公平分配系统资源，确保所有应用程序都能高效运行，并提供良好的用户体验。

文中给出了微内核的IPC调用频次：微内核不同服务之间需要通过IPC通信，相比宏内核直接函数调用的方式，性能有所损耗。而新兴场景中，IPC频率快速增加，论文中给出了一个数据，智能手机（平均每秒41,000次）和智能车辆（平均每秒7,000次）的IPC频率远高于路由器（平均每秒0.6次，类似于特定领域场景）。这不仅仅是由于更高的系统调用频率（61,000次/秒，是路由器的13倍），还包括大量的文件操作（IPC至文件系统）和内存映射文件上的频繁页面错误（每秒5,000次）。这些页面错误需要在内存管理器和文件系统之间进行额外的IPC往返。

XPC: Architectural Support for Secure and Efficient Cross Process Call

文章指出IPC是影响操作系统性能的主要因素，且IPC在例如Android Linux等单片内核中也发挥着重要作用，移动应用经常通过IPC与大量用户级服务进行通信。而以前的软件优化通常无法绕过负责域切换和消息复制/重映射的内核。硬件解决方案(如标记内存或功能)为了隔离而替换页表，但通常需要对现有软件堆栈进行大量修改，以适应新的硬件原语。因此本文提出了一种基于硬件辅助的操作系统原语XPC (Cross Process Call)，用于实现快速、安全的同步IPC。XPC支持IPC调用方和被调用方之间的直接切换，而不需要陷进内核，并且支持通过调用链跨多个进程传递消息，而不需要复制。

以前的优化ipc方法，有通过软件和硬件的，对于大多数软件解决方法，陷入内核的开销无法避免，消息传递将导致多次复制或TLB关闭。硬件解决方法，如codom，利用标记内存而不是页表来实现隔离，它们采用单地址空间，减少了域交换和消息传递的开销。这些新的硬件解决方案通常需要对针对多个地址空间设计的现有内核实现进行大量修改。

文章的新原语包含三个部分：
第一个是新的硬件感知抽象x-entry，每个x-entry都有自己的ID，并使用一个新功能xcall-cap进行访问控制。该功能由内核管理以提高灵活性，由硬件检查以提高效率。
第二种是一组新的指令，包括xcall和xret，它们允许用户级代码在不涉及内核的情况下直接在进程间切换。
第三种是一种新的地址空间映射机制，名为relayseg(“中继内存段”的缩写)，用于在调用者和被调用者之间零复制消息传递。（映射由一个新的寄存器完成，该寄存器指定消息的虚拟地址和物理地址的基础和范围，这种机制通过确保在任何时候只有一个消息所有者来支持消息的所有权转移，这可以防止TOCTTOU攻击，并且在域切换后不需要TLB刷新。中继seg也可以通过调用链传递，也就是切换，以进一步减少复制的数量。）

### 用户态中断

用户态中断（User Interrupt）指的是能够在用户态注册中断处理函数，并且也能够在用户态触发指定的中断处理函数。

RISC-V于2020年11月, 提出了[N指令扩展规范](https://five-embeddev.com/riscv-isa-manual/latest/n.html) 其中就有支持用户态中断的设计。Intel于2021年5月发布的[软件开发指南](https://www.intel.com/content/dam/develop/external/us/en/documents/architecture-instruction-set-extensions-programming-reference.pdf)中表述了x86架构下用户态中断的实现以及特性, 这也是本项目采用的平台。

用户态中断有低延迟, 低CPU占用的特点, 中断的接收和发送无需经过操作系统内核。同时用户态中断的发送方可以是用户态的程序, 也可以是内核。对于支持用户态中断的程序, 硬件是商业化的硬件, 对操作系统的修改也只是增量的添加系统调用。

用户态的以上特性满足了微内核对于在低修改成本的情况下获得高IPC性能的需求, 同时也满足宏内核对于内核能够发送中断到用户态的需求。

同时针对此机制，目前没有成熟的学术研究成果，因此本文的很多工作都是借鉴了社区中一些现有工作的参考，但现有工作基本基于宏内核如Linux进行，针对微内核的研究目前是空白的。

## 已经开展的研究工作

1.完成用户态中断相应资料和现有研究的调研。
2.已向x86架构的微内核rel4移植用户态中断支持并通过基准测试，实现在多核和单核情况下收发用户态中断。
3.已完成代码实验：对微内核的现有IPC（Slowpath, FastPath）和Uintr做ping-pong实验，衡量完成一次IPC所需要的 cpu cycles。
4.已在微内核rel4完成Intel 82574的网卡驱动配置，已在仿照Linux的io-uring构思简单的异步IO框架和相应的测试程序。
5.在Qemu上完成ping-pong实验，得到数据。

## 未来的进度计划

全部的预期计划为：

1.实验的平台使用微内核架构，微内核选择rel4，他是sel4微内核的Rust重写尝试（但大部分仍是C代码，重写进度比较缓慢），需要搭建编译环境和运行环境（C+Rust混合编译+链接），通过官方的基准测试。
2.调研Intel和Linux官方给出的适配用户态中断的Linux内核，了解用户态中断的处理过程和内核应该完成的系统调用。
3.宏内核（linux）和微内核（rel4）有本质上的区别，在此之前没有人对微内核做用户态中断的开发工作，因此所有标准和实现方式需要我自己根据微内核特点做修改适配，并通过基准测试。
4.用户态中断需要区分多核和单核情况，单核情况下只有一个线程在实时运行，接受线程被阻塞，如何在微内核调度好这个情况需要做一定的测试和适配。
5.对用户态中断，Linux内部评审邮件上与Intel官方给出其IPC效率是信号、eventfd、epoll等机制的8-10倍（基于Ipc-bench项目），但在微内核上只有IPC这一类系统调用，因此衡量标准需要与微内核适配，测试其原有的两种IPC方式（Slowpath, FastPath）与用户态中断Uintr的IPC效率。
6.除去用户态中断的高性能，其特殊的通知机制带来了极高的即时性，可以在异步IO场景中降低因为计算任务阻塞导致异步IO的完成时延上升（如Linux主分支的最新的高性能异步IO框架io-uring需要用户程序轮询完成队列来结束IO任务，如被计算任务阻塞将导致无法快速的、即时的完成IO），因此编写相应的简单异步IO框架，叠加大量计算任务，测试不同场景下的任务总时延和IO任务即时性时延。预期是使用用户态中断将用户态程序主动轮询改为被动接受中断信号，在中断函数中处理IO，同时实现异步IO带来总时间的降低和同步IO的最低IO时延。
7.实验平台选择Qemu（趋势正确，但具体数值不严谨）和实体CPU（选择Intel Sapphire Rapids 架构的CPU）。
8.结合文献资料调研、架构设计、实验数据撰写论文。

目前剩下678没有完成。


